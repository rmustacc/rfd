<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<title>
DDI_UFM(9E)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">ddi_ufm</b>, <b class="name">ddi_ufm_op_nimages</b>, <b class="name">ddi_ufm_op_fill_image</b>, <b class="name">ddi_ufm_op_nslots</b>, <b class="name">ddi_ufm_op_fil_slot</b> &#8212; <span class="desc">DDI upgradable firmware module entry points</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <span class="type">typedef struct ddi_ufm_handle ddi_ufm_handle_t</span><br/>
<span class="type">typedef struct ddi_ufm_ops ddi_ufm_ops_t</span><div class="spacer">
</div>
<b class="includes">#include &lt;<a class="link-includes">sys/ddi_ufm.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">ddi_ufm_op_nimages</b>(<i class="farg">ddi_ufm_handle_t *uhp</i>, <i class="farg">void *drv_arg</i>, <i class="farg">uint_t *nimgp</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">ddi_ufm_op_fill_image</b>(<i class="farg">ddi_ufm_handle_t *uhp</i>, <i class="farg">void *drv_arg</i>, <i class="farg">uint_t imgid</i>, <i class="farg">ddi_ufm_image_t *uip</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">ddi_ufm_op_nslots</b>(<i class="farg">ddi_ufm_handle_t *uhp</i>, <i class="farg">void *drv_arg</i>, <i class="farg">uint_t *nslotsp</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">ddi_ufm_fill_slot</b>(<i class="farg">ddi_ufm_handle_t *uhp</i>, <i class="farg">void *drv_arg</i>, <i class="farg">uint_t imgid</i>, <i class="farg">uint_t slotid</i>, <i class="farg">ddi_ufm_slot_t *usp</i>);</div>
<div class="section">
<h1 id="x494e54455246414345204c4556454c">INTERFACE LEVEL</h1> <span class="symb">Evolving -</span> This interface is evolving still in illumos. API and ABI stability is not guaranteed.</div>
<div class="section">
<h1 id="x504152414d4554455253">PARAMETERS</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">uhp</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
A handle corresponding to the device's UFM handle. This is the same value as returned in <a class="link-man">ddi_ufm_init(9F)</a>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">drv_arg</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
This is a private value that the drier passed in when calling <a class="link-man">ddi_ufm_init(9F)</a>. <i class="farg">nimgp</i> A pointer that the driver should set with a number of images. <i class="farg">nslotp</i> A pointer that the driver should set with a number of slots.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">imgid</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
An integer indicating which image information is being requested for.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">uip</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
An opaque pointer that represents a UFM image.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">slotid</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
An integer indicating which slot information is being requested for.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">usp</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
An opaque pointer that represents a UFM slot.</dd>
</dl>
</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> Upgradable firmware modules (UFM) are a potential component of many devices. These interfaces aim to provide a simple series of callbacks for a device driver to implement such that it is easy to report information and in the future, manipulate firmware modules.<div class="subsection">
<h2 id="x55464d204261636b67726f756e64">UFM Background</h2> UFMs may come in different flavors and styles ranging from a firmware blob, to an EEPROM image, to microcode, and more. Take for example a hard drive. While it contains a field replaceable unit (FRU), it also contains some amount of firmware that manages the drive and can be updated independently of replacing the drive.<div class="spacer">
</div>
The motherboard often has a UFM in the form of the BIOS or UEFI. The Lights out management controller on a system has a UFM, which is usually the entire system image. CPUs also have a UFM in the form of microcode.<div class="spacer">
</div>
An important property of a UFM is that it is a property of the device itself. For example, many WiFi device drivers are required to send a binary blob of firmware to the device after every reset. Because these images are not properties of the device and must be upgraded by either changing the device driver or related system files, we do not consider these UFMs.<div class="spacer">
</div>
There are also devices that have firmware which is a property of the device, but may not be upgradable from the running OS. This may be because the vendor doesn't have tooling to upgrade the image or because the firmware image itself cannot be upgraded in the field at all. For example, a YubiKey has a firmware image that's burned into it in the factory, but there is no way to change the firmware on it short of replacing the device in its entirety.  However, because these images are a permanent part of the device, we also consider them a UFM.</div>
<div class="subsection">
<h2 id="x496d6167657320616e6420536c6f7473">Images and Slots</h2> A device that supports UFMs is made up of one or more distinct firmware images. Each image has its own unique purpose. For example, a motherboard may have both a BIOS and a CPLD image, each of which has independent firmware revisions.<div class="spacer">
</div>
A given image may have a number of slots. A slot represents a particular version of the image. Only one slot can be active at a given time. Devices support slots such that a firmware image can be downloaded to the device without impacting the current device if it fails half-way through.  The slot that's currently in use is referred to as the <span class="emph">active</span> slot.<div class="spacer">
</div>
The various entry points are designed such that all a driver has to do is provide information about the image and its slots to the kernel, it does not have to wrangle with how that is marshalled to users and the appearance of those structures.</div>
<div class="subsection">
<h2 id="x5265676973746572696e672077697468207468652055464d2053756273797374656d">Registering with the UFM Subsystem</h2> During a device driver's <a class="link-man">attach(9E)</a> entry point, a device driver should register with the UFM subsystem by filling out a UFM operations vector and then calling <a class="link-man">ddi_ufm_init(9F)</a>. The driver may pass in a value, usually a pointer to its soft state pointer, which it will then receive when its subsequent entry points are called.<div class="spacer">
</div>
Once the driver has finished initializing, it must call <a class="link-man">ddi_ufm_update(9F)</a> to indicate that the driver is in a state where it's ready to receive calls to the entry points.<div class="spacer">
</div>
The various UFM entry points may be called from an arbitrary kernel context. However, they will only ever be called from a single thread at a given time.</div>
<div class="subsection">
<h2 id="x55464d206f7065726174696f6e7320766563746f72">UFM operations vector</h2> The UFM operations vector is a structure that has the following members:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
typedef struct ddi_ufm_ops { 
	int (*ddi_ufm_op_nimages)(ddi_ufm_handle_t *uhp, void *arg, 
	    uint_t *nimgp); 
	int (*ddi_ufm_op_fill_image)(ddi_ufm_handle_t *uhp, void *arg, 
            uint_t imgid, ddi_ufm_image_t *img); 
	int (*ddi_ufm_op_nslots)(ddi_ufm_handle_t *uhp, void *arg, 
            uint_t imgid, uint_t *nslots); 
	int (*ddi_ufm_op_fill_slot)(ddi_ufm_handle_t *uhp, void *arg, 
            int imgid, ddi_ufm_image_t *img, uint_t slotid, 
	    ddi_ufm_slot_t *slotp); 
} ddi_ufm_ops_t;</pre>
<div class="spacer">
</div>
Of the four members, only the <b class="fname">ddi_ufm_op_fill_image</b>() and <b class="fname">ddi_ufm_op_fill_slot</b>() are required. The other entry points are optional. If a device only has a single image, then there is no reason to implement the <b class="fname">ddi_ufm_op_nimages</b>() entry point. The system will assume that there is only a single image. The same holds true for the <b class="fname">ddi_ufm_op_nslots</b>() entry point. If only a single slot is supported, then the driver should not bother implementing this entry point.<div class="spacer">
</div>
Slots and images are numbered starting at zero. If a driver indicates support for multiple images or slots then the images or slots will be numbered sequentially going from 0 to the number of images or slots minus one. These values will be passed to the various entry points to indicate which image and slot the system is interested in. It is up to the driver to maintain a consistent view of the images and slots for a given UFM.<div class="spacer">
</div>
The members of this structure should be filled in the following ways:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">ddi_ufm_op_nimages</b>()</dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
The <b class="fname">ddi_ufm_op_nimages</b>() entry point is an optional entry point that answers the question of how many different, distinct firmware images are present on the device. Once the driver determines how many are present, it should set the value in <i class="farg">nimgp</i> to the determined value.<div class="spacer">
</div>
It is legal for a device to pass in zero for this value, which indicates that there are none present.<div class="spacer">
</div>
Upon successful completion, the driver should return <span class="symb">0</span>. Otherwise, the driver should return the appropriate error number. For a full list of error numbers, see <a class="link-man">Intro(2)</a>. Common values are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="errno">EIO</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
An error occurred while communicating with the device to determine the number of firmware images.</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">ddi_ufm_op_fill_image</b>()</dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
The <b class="fname">ddi_ufm_op_fill_image</b>() entry point is used to fill in information about a given image. The value in <i class="farg">imgid</i> is used to indicate which image the system is asking to fill information about. If the driver does not recognize the image ID in <i class="farg">imgid</i> then it should return an error.<div class="spacer">
</div>
The <i class="ftype">ddi_ufm_image_t</i> structure passed in <i class="farg">uip</i> is opaque. To fill in information about the image, the driver should call the functions described in <a class="link-man">ddi_ufm_image(9F)</a>.<div class="spacer">
</div>
The driver should call the <a class="link-man">ddi_ufm_image_set_desc(9F)</a> function to set a description of the image which indicates its purpose. This should be a human-readable string. The driver may also set any ancillary data that it deems may be useful with the <a class="link-man">ddi_ufm_image_set_misc(9F)</a> function. This function takes an nvlist, allowing the driver to set arbitrary keys and values.<div class="spacer">
</div>
Once the driver has finished setting all of the information about the image then the driver should return <span class="symb">0</span>. Otherwise, the driver should return the appropriate error number. For a full list of error numbers, see <a class="link-man">Intro(2)</a>. Common values are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="errno">EINVAL</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The image indicated by <i class="farg">imgid</i> is unknown.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="errno">EIO</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
An error occurred talking to the device while trying to fill out firmware image information.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="errno">ENOMEM</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The driver was unable to allocate memory while filling out image information.</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">ddi_ufm_op_nslots</b>()</dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
The <b class="fname">ddi_ufm_op_nslots</b>() entry point is an optional entry point that answers the question of how many different slots exist for the firmware image indicated by <i class="farg">imgid</i>. If <i class="farg">imgid</i> is an unknown image, then the driver should return an error.<div class="spacer">
</div>
Once the driver has determined the number of slots, it should update <i class="farg">nslotp</i> with the number.<div class="spacer">
</div>
A device driver should not set <i class="farg">nslotp</i> to zero as every firmware image is required to have a slot.<div class="spacer">
</div>
Upon successful completion, the driver should return <span class="symb">0</span>. Otherwise, the driver should return the appropriate error number. For a full list of error numbers, see <a class="link-man">Intro(2)</a>. Common values are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="errno">EINVAL</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The image indicated by <i class="farg">imgid</i> is unknown.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="errno">EIO</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
An error occurred while communicating with the device to determine the number of slots for the firmware image.</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">ddi_ufm_op_fill_slot</b>()</dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
The <b class="fname">ddi_ufm_op_fill_slot</b>() function is used to fill in information about a specific slot for a specific image. The value in <i class="farg">imgid</i> indicates the image the system wants slot information for and the value in <i class="farg">slotid</i> indicates which slot of that image the system is interested in. If the device driver does not recognize the value in either or <i class="farg">imgid</i> or <i class="farg">slotid</i>, then it should return an error.<div class="spacer">
</div>
The <i class="ftype">ddi_ufm_slot_t</i> structure passed in <i class="farg">usp</i> is opaque. To fill in information about the image the driver should call the functions described in <a class="link-man">ddi_ufm_slot(9F)</a>.<div class="spacer">
</div>
The driver should call the <a class="link-man">ddi_ufm_slot_set_version(9F)</a> function to indicate the version of the UFM. The version is a device-specific character string. It should contain the current version of the UFM as a human can understand it and it should try to match the format used by device vendor.<div class="spacer">
</div>
The <a class="link-man">ddi_ufm_slot_set_attrs(9F)</a> function should be used to set the attributes of the UFM slot. These attributes include the following enumeration values:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">DDI_UFM_ATTR_READABLE</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
This attribute indicates that the firmware image in the specified slot may be read, even if the device driver does not currently support such functionality.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">DDI_UFM_ATTR_WRITEABLE</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
This attributes indicates that the firmware image in the specified slot may be updated, even if the driver does not currently support such functionality.</dd>
</dl>
<div class="spacer">
</div>
The <a class="link-man">ddi_ufm_set_primary(9F)</a> function should be used to indicate whether the specified slot is the primary slot. The primary slot is the one whose firmware revision is actively being used. If there is only one slot, then there is no need to call this function, it is always considered the primary.<div class="spacer">
</div>
Finally, if there are any device-specific key-value pairs that form useful, ancillary data, then the driver should assemble an nvlist and pass it to the <a class="link-man">ddi_ufm_set_misc(9F)</a> function.<div class="spacer">
</div>
Once the driver has finished setting all of the information about the slot then the driver should return <span class="symb">0</span>. Otherwise, the driver should return the appropriate error number. For a full list of error numbers, see <a class="link-man">Intro(2)</a>. Common values are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="errno">EINVAL</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The image or slot indicated by <i class="farg">imgid</i> and <i class="farg">slotid</i> is unknown.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="errno">EIO</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
An error occurred talking to the device while trying to fill out firmware slot information.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="errno">ENOMEM</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The driver was unable to allocate memory while filling out slot information.</dd>
</dl>
</dd>
</dl>
</div>
<div class="subsection">
<h2 id="x43616368696e6720616e642055706461746573">Caching and Updates</h2> The system will fetch firmware and slot information on an as-needed basis. Once it obtains some information, it may end up caching this information on behalf of the driver. Whenever the driver believes that something could have changed -- it need know that it has -- then the driver must call <a class="link-man">ddi_ufm_update(9F)</a>.</div>
<div class="subsection">
<h2 id="x696f63746c20496e746567726174696f6e">ioctl Integration</h2> The UFM device driver interface will set properties on the device nodes to indicate that it supports various UFM operations. When the system sees this, then it will know that the driver supports various UFM ioctls. To facilitate this, there are two different functions that a driver can use in its <a class="link-man">ioctl(9E)</a> routine.<div class="spacer">
</div>
The first routine is <a class="link-man">ddi_ufm_is_ioctl(9F)</a> which determines whether or not a specified command is a UFM ioctl. If the command is a UFM ioctl, then the driver must call into the UFM subsystem to handle it. Otherwise, it can proceed to handle the ioctl normally.<div class="spacer">
</div>
To handle a UFM ioctl, a driver should call <a class="link-man">ddi_ufm_ioctl(9F)</a> with all of the arguments that it received from the ioctl. Note, that this function will completely handle the ioctl and then return. The driver does not have to perform any individual checks or operations. The UFM subsystem will automatically handle any and all needed credentials checks. The driver should simply return the value that is returned by <a class="link-man">ddi_ufm_ioctl(9F)</a>.</div>
<div class="subsection">
<h2 id="x4c6f636b696e67">Locking</h2> All UFM operations on a single UFM handle will always be run serially. However, the device driver may still need to apply adequate locking to its structure members as other  may be accessing the same data structure or trying to communicate with the device.<div class="spacer">
</div>
The driver must not hold any locks while calling either <a class="link-man">ddi_ufm_is_ioctl(9F)</a> or <a class="link-man">ddi_ufm_ioctl(9F)</a>. A call to handle an ioctl may result in calling into a driver's UFM entry points from another thread.</div>
<div class="subsection">
<h2 id="x556e7265676973746572696e672066726f6d207468652055464d2073756273797374656d">Unregistering from the UFM subsystem</h2> When a device driver is detached, it should unregister from the UFM subsystem. To do so, the driver should call <a class="link-man">ddi_ufm_fini(9F)</a>. By the time this function returns, the driver is guaranteed that no UFM entry points will be called. However, if there are outstanding UFM related activity, the function will block until it is terminated.</div>
</div>
<div class="section">
<h1 id="x434f4e54455854">CONTEXT</h1> The various UFM entry points that a device driver must implement will always be called from <span class="symb">kernel</span> context.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man">Intro(2)</a>, <a class="link-man">attach(9E)</a>, <a class="link-man">ioctl(9E)</a>, <a class="link-man">ddi_ufm_fini(9F)</a>, <a class="link-man">ddi_ufm_image(9F)</a>, <a class="link-man">ddi_ufm_image_set_desc(9F)</a>, <a class="link-man">ddi_ufm_image_set_misc(9F)</a>, <a class="link-man">ddi_ufm_init(9F)</a>, <a class="link-man">ddi_ufm_ioctl(9F)</a>, <a class="link-man">ddi_ufm_is_ioctl(9F)</a>, <a class="link-man">ddi_ufm_set_misc(9F)</a>, <a class="link-man">ddi_ufm_set_primary(9F)</a>, <a class="link-man">ddi_ufm_slot(9F)</a>, <a class="link-man">ddi_ufm_slot_set_attrs(9F)</a>, <a class="link-man">ddi_ufm_slot_set_version(9F)</a>, <a class="link-man">ddi_ufm_update(9F)</a></div>
</div>
</body>
</html>

