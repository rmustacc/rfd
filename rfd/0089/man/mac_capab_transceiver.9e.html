<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<title>
MAC_CAPAB_TRANSCEIVER(9E)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">MAC_CAPAB_TRANSCEIVER</b>, <b class="name">mac_transceiver_kind</b>, <b class="name">mac_capab_transciever</b>, <b class="name">mct_info</b>, <b class="name">mct_read</b> &#8212; <span class="desc">MAC capability for networking transceivers</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/mac_provider.h</a>&gt;</b><div class="spacer">
</div>
<span class="type">typedef struct mac_capab_transceiver mac_capab_transceiver_t;</span><br/>
<span class="type">typedef enum mac_transceiver_kind mac_transceiver_kind_t;</span><div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">mct_info</b>(<i class="farg">void *driver</i>, <i class="farg">uint_t id</i>, <i class="farg">mac_transceiver_info_t *infop</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">mct_read</b>(<i class="farg">void *driver</i>, <i class="farg">uint_t id</i>, <i class="farg">uint_t page</i>, <i class="farg">void *buf</i>, <i class="farg">size_t nbytes</i>, <i class="farg">off_t offset</i>, <i class="farg">size_t *nwritten</i>);</div>
<div class="section">
<h1 id="x494e54455246414345204c4556454c">INTERFACE LEVEL</h1> <span class="symb">Evolving -</span> This interface is evolving still in illumos. API and ABI stability is not guaranteed.</div>
<div class="section">
<h1 id="x504152414d4554455253">PARAMETERS</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">driver</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
A pointer to the driver's private data that was passed in via the <span class="symb">m_pdata</span> member of the <a class="link-man">mac_register(9S)</a> structure to the <a class="link-man">mac_register(9F)</a> function.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">id</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
An integer value indicating which transceiver is being inquired about.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">infop</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
An opaque structure which is used to set information about the transceiver.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">page</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
A value that indicates which page from the i2c bus is being requested.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">buf</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
A pointer to which data should be written to when reading from the device.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">nbytes</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
A value indicating the number of bytes being asked to read into <i class="farg">buf</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">offset</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
A value indicating the offset into the page to start reading data.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">nwritten</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
A value to be updated by the driver with the number of successfully read bytes.</dd>
</dl>
</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <span class="symb">MAC_CAPAB_TRANSCEIVER</span> capability allows for GLDv3 networking device drivers to provide information to the system about their transceiver. Implementing this capability is optional. For more information on how to handle capabilities and how to indicate that a capability is not supported, see <a class="link-man">mc_getcapab(9E)</a>.<div class="spacer">
</div>
This capability should be implemented if the device in question supports a Small Form Factor (SFF) transceiver. These are more commonly known by names such as SFP, SFP+, SFP28, QSFP+, and QSFP28. This interface does not apply to traditional copper Ethernet phys. These transceivers provide standardized information over the i2c bus at specific pages.<div class="subsection">
<h2 id="x537570706f72746564205374616e6461726473">Supported Standards</h2><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="symb">INF-8074</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The <span class="symb">INF-8084</span> standard was the original multisource agreement (MSA) for SFP devices. It proposed the original series of management pages at i2c page 0xa0. This page contained up to 512 bytes, however, only the first 96 bytes are standardized. The remaining bytes are The management page was subsequently adopted by SFP+ devices.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="symb">SFF-8472</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The <span class="symb">SFF-8472</span> standard extended the original SFP MSA. This standard added a second i2c page at 0xa2, while maintaining the original page at 0xa0. The page at 0xa0 is now explicitly 256 bytes. The page at 0xa2 is also 256 bytes. This standard was also adopted for all SFP28 parts, which are commonly used in transceivers for 25 Gb/s Ethernet.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="symb">SFF-8436</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The <span class="symb">SFF-8436</span> standard was developed for QSFP+ transceivers, which involve the bonding of 4 SFP+ links. QSFP+ is commonly used in the transceivers for 40 Gb/s Ethernet.  This standard uses i2c page 0x00 for read-only identification purposes. The lower half of the page is used for control, while the upper 128 bytes is similar to the <span class="symb">INF-8084</span> and <span class="symb">SFF-8472</span> standards.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="symb">SFF-8636</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The <span class="symb">SFF-8636</span> standard is a common management standard which is shared between both SAS and QSFP+ 28 Gb/s transceivers. The latter transceiver is commonly found in 100 Gb/s Ethernet. The transceiver's memory map is similar to that found in the <span class="symb">SFF-8436</span> specification. The identification information is found in the upper 128 bytes of page 0x00, while the lower part of the page is used for control, among other purposes.</dd>
</dl>
<div class="spacer">
</div>
The following table summarizes the above information.<table style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-col">
<col style="width: 11.00ex;"/>
<col style="width: 24.00ex;"/>
<col style="width: 9.00ex;"/>
<col style="min-width: 10.00ex;"/>
<tbody>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="emph">Standard</span></td>
<td class="list-col" style="margin-top: 1.00em;">
<span class="emph">Speeds</span></td>
<td class="list-col" style="margin-top: 1.00em;">
<span class="emph">Size</span></td>
<td class="list-col" style="margin-top: 1.00em;">
<span class="emph">i2c pages</span></td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
INF-8074</td>
<td class="list-col" style="margin-top: 1.00em;">
1 Gb/s, 10 Gb/s</td>
<td class="list-col" style="margin-top: 1.00em;">
256 bytes</td>
<td class="list-col" style="margin-top: 1.00em;">
0xa0</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
SFF-8472</td>
<td class="list-col" style="margin-top: 1.00em;">
1 Gb/s, 10 Gb/s, 25 GB/s</td>
<td class="list-col" style="margin-top: 1.00em;">
512 bytes</td>
<td class="list-col" style="margin-top: 1.00em;">
0xa0, 0xa2</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
SFF-8436</td>
<td class="list-col" style="margin-top: 1.00em;">
40 Gb/s</td>
<td class="list-col" style="margin-top: 1.00em;">
256 bytes</td>
<td class="list-col" style="margin-top: 1.00em;">
0x00</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
SFF-8636</td>
<td class="list-col" style="margin-top: 1.00em;">
100 Gb/s</td>
<td class="list-col" style="margin-top: 1.00em;">
256 bytes</td>
<td class="list-col" style="margin-top: 1.00em;">
0x00</td>
</tr>
</tbody>
</table>
</div>
<div class="subsection">
<h2 id="x4d4143204361706162696c69747920537472756374757265">MAC Capability Structure</h2> When the device driver's <a class="link-man">mc_getcapab(9E)</a> function entry point is called with the capability requested set to <span class="symb">MAC_CAPAB_TRANSCEIVER</span>, then the value of the capability structure is the following structure:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
typedef struct mac_capab_transceiver { 
	uint_t	mct_flags; 
	uint_t	mct_ntransceiveres; 
	int	(*mct_info)(void *driver, uint_t id, 
		    mac_transceiver_info_t *infop), 
	int	(*mct_read)(void *driver, uint_t id, uint_t page, 
		    void *buf, size_t nbytes, off_t offset, 
		    size_t *nwritten) 
} mac_capab_transceiver_t;</pre>
<div class="spacer">
</div>
If the device driver supports the <span class="symb">MAC_CAPAB_TRANSCEIVER</span> capability, it should fill in this structure, based on the following rules:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="symb">mct_flags</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The <span class="type">mct_flags</span> member is used to negotiate extensions with the driver. MAC will set the value of <span class="type">mct_flags</span> to include all of the currently known extensions. The driver should intersect this list with the set that they actually support. At this time, no such features are defined and the driver should set the member to <span class="symb">0</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="symb">mct_ntransceivers</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The value of <span class="symb">mct_ntransceivers</span> indicates that the number of transceivers present in the device. For most devices, it is expected that this value will be set to one. However, some devices do support multiple transceivers and PHYs that show up behind a single logical MAC.<div class="spacer">
</div>
It is expected that this value will not change across the lifetime of the device being attached. It is important to remember that this represents the total possible number of transceivers in the device, not how many are currently present and powered on.<div class="spacer">
</div>
The number of transceivers will influence the <i class="farg">id</i> argument used in the <b class="fname">mct_info</b>() and <b class="fname">mct_read</b>() entry points. The transceiver IDs will start at zero and go to the value of <i class="farg">mct_ntransceivers - 1</i>. It is up to the driver to keep the mapping between actual transceivers and the transceiver identifiers consistent.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="symb">mct_info</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The <b class="fname">mct_info</b>() entry point is used to set basic information about the transceiver. This entry point is <span class="emph">required</span>. If the device driver cannot implement this entry point, then it should not indicate that it supports the capability.<div class="spacer">
</div>
The <b class="fname">mct_info</b>() entry point should fill in information about the transceiver with an identifier of <i class="farg">id</i>. See the description above of <span class="symb">mct_ntransceivers</span> for more information on how the IDs are determined.<div class="spacer">
</div>
The driver should then proceed to fill in basic information by calling the functions described in the section <i class="link-sec"><a class="link-sec" href="#x496e666f726d6174696f6e2046756e6374696f6e73">Information Functions</a></i>. After successfully calling all of the functions, the driver should return <span class="symb">0</span>. Othewrise, it should return the appropriate error number. For a full list of error numbers, see <a class="link-man">Intro(2)</a>. Common values are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="errno">EINVAL</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The transceiver identifier <i class="farg">id</i> was invalid.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="errno">ENOTSUP</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
This instance of the devices does not support a transceiver. For example, a device which sometimes has copper PHYsand therefore this instance does not have any PHYs.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="errno">EIO</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
An error occurred while trying to read device registers. For example, an FM-aware device had an error.</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="symb">mct_read</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The <b class="fname">mct_read</b>() function is used to read information from a transceiver's i2c bus. The <b class="fname">mct_read</b>() entry point is an <span class="emph">optional</span> entry point.<div class="spacer">
</div>
The transceiver should first check the value of <i class="farg">id</i>, which indicates which transceiver information is being requested.  See the description above of <span class="symb">mct_ntransceivers</span> for more information on how the IDs are determined.<div class="spacer">
</div>
The driver should try to read up to <i class="farg">nbytes</i> of data from the i2c bus at page <i class="farg">page</i>. The driver should start reading at offset <i class="farg">offset</i>. Finally, it should update the value in <i class="farg">nwritten</i> with the number of bytes written to the buffer <i class="farg">buf</i>.<div class="spacer">
</div>
If for some reason the driver cannot read all of the requested bytes, that is acceptable. Instead it should perform a short read. This may occur because the transceiver does not allow reads at a requested region or the region is shorter than is common for most devices.<div class="spacer">
</div>
Upon successful completion, the driver should ensure that <i class="farg">nwritten</i> has been updated and then return <span class="symb">0</span>. Otherwise, the driver should return the appropriate error number. For a full list of error numbers, see <a class="link-man">Intro(2)</a>. Common values are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="errno">EINVAL</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The value of <i class="farg">id</i> represented an invalid transceiver identifier. The transceiver i2c page <i class="farg">page</i> is not valid for this type of device. The value of <i class="farg">offset</i> is beyond the range supported for this <i class="farg">page</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="errno">EIO</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
An error occurred while trying to read the device i2c pages.</dd>
</dl>
</dd>
</dl>
</div>
<div class="subsection">
<h2 id="x5472616e7363656976657220496e666f726d6174696f6e2046756e6374696f6e73">Transceiver Information Functions</h2> The <b class="fname">mct_info</b>() entry point is the primary required entry point for a device driver which supports this capability. The information structure is opaque to the device driver. Instead, a series of informational functions is available to the device driver to call on the transceiver. The device drivers should try to call and fill in as many of these as possible. There are three different properties that a driver can set:<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 1.00em;">
The kind of the transceiver.</li>
<li class="list-enum" style="margin-top: 1.00em;">
Whether the transceiver is present.</li>
<li class="list-enum" style="margin-top: 1.00em;">
Whether the transceiver is usable.</li>
</ol>
<div class="spacer">
</div>
To set the transceiver kind, the driver should call <a class="link-man">mac_transceiver_info_set_type(9F)</a>. The transceiver's kind comes from the following enumeration of values from the enumerator <span class="define">mac_transceiver_kind_t</span>:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MAC_TRANSCEIVER_UNKNOWN</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
The transceiver's kind is unknown.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MAC_TRANSCEIVER_SYNTHETIC</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
The device firmware does not allow direct access to the transceiver and instead abstracts it.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MAC_TRANSCEIVER_INF_8074</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
The transceiver is compliant with the <span class="symb">INF-8074</span> MSA and implements the i2c informational page 0xa0.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MAC_TRANSCEIVER_SFF_8472</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
The transceiver conforms to the <span class="symb">INF-8472</span> standard and implements the i2c informational page 0xa0 and 0xa2.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MAC_TRANSCEIVER_SFF_8436</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
The transceiver conforms to the <span class="symb">SFF-8436</span> standard and implements the i2c informational page 0x00.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MAC_TRANSCEIVER_SFF_8636</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
The transceiver conforms to the <span class="symb">SFF-8636</span> standard and implements the i2c informational page 0x00.</dd>
</dl>
<div class="spacer">
</div>
To set whether or not the transceiver is present, the driver should call <a class="link-man">mac_transceiver_info_set_present(9F)</a>. This is used to indicate whether the transceiver is plugged in or not. If the transceiver is a part of the NIC, then this function should always be called with the value set to <span class="define">B_TRUE</span>.<div class="spacer">
</div>
Finally, the driver has the ability to provide information about whether or not the transceiver is usable or not. A transceiver may be present, but not usable, if the hardware and firmware support a limited number of transceivers. To set this information, the driver should call <a class="link-man">mac_transceiver_info_set_usable(9F)</a>. If the transceiver is not present, then the driver should not call this function.</div>
<div class="subsection">
<h2 id="x4f7061717565205472616e7363656976657273">Opaque Transceivers</h2> Some devices abstract the nature of the transceiver and do not allow direct access to the transceiver. In this case, if the device driver still has access to enough information to know if the transceiver is at least present, then it should still implement the <b class="fname">mct_info</b>() entry point and set the transceiver kind to <span class="define">MAC_TRANSCEIVER_SYNTHETIC</span>.</div>
<div class="subsection">
<h2 id="x4c6f636b696e6720616e64204461746120416363657373">Locking and Data Access</h2> Calls to get information about the transceivers may come at the same time as general I/O requests to the device to send or receive data. The driver should make sure that reading data from the i2c bus of the transceiver does not interfere with the device's functionality in this regard. Different locks should be used.<div class="spacer">
</div>
On some devices, reading from the transceiver's i2c bus might cause a disruption of service to the device. For example, on some devices a phy reset may be required or come about as a side effect of trying to read the device. If any kind of disruption would be caused, then the driver must not implement the <i class="ftype">mct_read</i> entry point.</div>
</div>
<div class="section">
<h1 id="x434f4e54455854">CONTEXT</h1> The various callback functions will be called from <span class="symb">kernel</span> context. These functions will never be called from <span class="symb">interrupt</span> context.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man">Intro(2)</a>, <a class="link-man">mac(9E)</a>, <a class="link-man">mc_getcapab(9E)</a>, <a class="link-man">mac_register(9F)</a>, <a class="link-man">mac_transceiver_info_set_present(9F)</a>, <a class="link-man">mac_transceiver_info_set_type(9F)</a>, <a class="link-man">mac_transceiver_info_set_usable(9F)</a>, <a class="link-man">mac_register(9S)</a>,<div class="spacer">
</div>
<span class="ref"><span class="ref-title">SFP (Small Formfactor Pluggable) Interface</span>, <span class="ref-num">INF-8074i</span>, <span class="ref-corp">SFF Committee</span>, <span class="ref-date">May 12, 2001</span>, <span class="ref-opt">Revision 1.0</span>.</span><div class="spacer">
</div>
<span class="ref"><span class="ref-title">Diagnostic Monitoring Interface for Optical Transceivers</span>, <span class="ref-num">SFF-8472</span>, <span class="ref-date">November 21, 2014</span>, <span class="ref-opt">Revision 12.2</span>.</span><div class="spacer">
</div>
<span class="ref"><span class="ref-title">QSFP+ 10 Gbs 4X PLUGGABLE TRANSCEIVER</span>, <span class="ref-num">SFF-8436</span>, <span class="ref-date">October 31, 2013</span>, <span class="ref-opt">Revision 4.8</span>.</span><div class="spacer">
</div>
<span class="ref"><span class="ref-title">Management Interface for Cabled Environments</span>, <span class="ref-num">SFF-8636</span>, <span class="ref-date">January 26, 2016</span>, <span class="ref-opt">Revision 2.7</span>.</span></div>
</div>
</body>
</html>

