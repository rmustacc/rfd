MAC_CAPAB_TRANSCEIVER(9E)     Driver Entry Points    MAC_CAPAB_TRANSCEIVER(9E)

NNAAMMEE
     MMAACC__CCAAPPAABB__TTRRAANNSSCCEEIIVVEERR, mmaacc__ttrraannsscceeiivveerr__kkiinndd, mmaacc__ccaappaabb__ttrraannsscciieevveerr,
     mmcctt__iinnffoo, mmcctt__rreeaadd - MAC capability for networking transceivers

SSYYNNOOPPSSIISS
     ##iinncclluuddee <<ssyyss//mmaacc__pprroovviiddeerr..hh>>

     _t_y_p_e_d_e_f _s_t_r_u_c_t _m_a_c___c_a_p_a_b___t_r_a_n_s_c_e_i_v_e_r _m_a_c___c_a_p_a_b___t_r_a_n_s_c_e_i_v_e_r___t_;
     _t_y_p_e_d_e_f _e_n_u_m _m_a_c___t_r_a_n_s_c_e_i_v_e_r___k_i_n_d _m_a_c___t_r_a_n_s_c_e_i_v_e_r___k_i_n_d___t_;

     _i_n_t
     mmcctt__iinnffoo(_v_o_i_d _*_d_r_i_v_e_r, _u_i_n_t___t _i_d, _m_a_c___t_r_a_n_s_c_e_i_v_e_r___i_n_f_o___t _*_i_n_f_o_p);

     _i_n_t
     mmcctt__rreeaadd(_v_o_i_d _*_d_r_i_v_e_r, _u_i_n_t___t _i_d, _u_i_n_t___t _p_a_g_e, _v_o_i_d _*_b_u_f, _s_i_z_e___t _n_b_y_t_e_s,
         _o_f_f___t _o_f_f_s_e_t, _s_i_z_e___t _*_n_w_r_i_t_t_e_n);

IINNTTEERRFFAACCEE LLEEVVEELL
     EEvvoollvviinngg -- This interface is evolving still in illumos. API and ABI
     stability is not guaranteed.

PPAARRAAMMEETTEERRSS
     _d_r_i_v_e_r        A pointer to the driver's private data that was passed in
                   via the mm__ppddaattaa member of the mac_register(9S) structure to
                   the mac_register(9F) function.

     _i_d            An integer value indicating which transceiver is being
                   inquired about.

     _i_n_f_o_p         An opaque structure which is used to set information about
                   the transceiver.

     _p_a_g_e          A value that indicates which page from the i2c bus is being
                   requested.

     _b_u_f           A pointer to which data should be written to when reading
                   from the device.

     _n_b_y_t_e_s        A value indicating the number of bytes being asked to read
                   into _b_u_f.

     _o_f_f_s_e_t        A value indicating the offset into the page to start
                   reading data.

     _n_w_r_i_t_t_e_n      A value to be updated by the driver with the number of
                   successfully read bytes.

DDEESSCCRRIIPPTTIIOONN
     The MMAACC__CCAAPPAABB__TTRRAANNSSCCEEIIVVEERR capability allows for GLDv3 networking device
     drivers to provide information to the system about their transceiver.
     Implementing this capability is optional. For more information on how to
     handle capabilities and how to indicate that a capability is not
     supported, see mc_getcapab(9E).

     This capability should be implemented if the device in question supports
     a Small Form Factor (SFF) transceiver. These are more commonly known by
     names such as SFP, SFP+, SFP28, QSFP+, and QSFP28. This interface does
     not apply to traditional copper Ethernet phys. These transceivers provide
     standardized information over the i2c bus at specific pages.

   SSuuppppoorrtteedd SSttaannddaarrddss
     IINNFF--88007744
             The IINNFF--88008844 standard was the original multisource agreement
             (MSA) for SFP devices.  It proposed the original series of
             management pages at i2c page 0xa0.  This page contained up to 512
             bytes, however, only the first 96 bytes are standardized. The
             remaining bytes are The management page was subsequently adopted
             by SFP+ devices.

     SSFFFF--88447722
             The SSFFFF--88447722 standard extended the original SFP MSA. This
             standard added a second i2c page at 0xa2, while maintaining the
             original page at 0xa0. The page at 0xa0 is now explicitly 256
             bytes. The page at 0xa2 is also 256 bytes.  This standard was
             also adopted for all SFP28 parts, which are commonly used in
             transceivers for 25 Gb/s Ethernet.

     SSFFFF--88443366
             The SSFFFF--88443366 standard was developed for QSFP+ transceivers, which
             involve the bonding of 4 SFP+ links. QSFP+ is commonly used in
             the transceivers for 40 Gb/s Ethernet.  This standard uses i2c
             page 0x00 for read-only identification purposes. The lower half
             of the page is used for control, while the upper 128 bytes is
             similar to the IINNFF--88008844 and SSFFFF--88447722 standards.

     SSFFFF--88663366
             The SSFFFF--88663366 standard is a common management standard which is
             shared between both SAS and QSFP+ 28 Gb/s transceivers. The
             latter transceiver is commonly found in 100 Gb/s Ethernet. The
             transceiver's memory map is similar to that found in the SSFFFF--88443366
             specification. The identification information is found in the
             upper 128 bytes of page 0x00, while the lower part of the page is
             used for control, among other purposes.

     The following table summarizes the above information.

           _S_t_a_n_d_a_r_d       _S_p_e_e_d_s                      _S_i_z_e         _i_2_c _p_a_g_e_s
           INF-8074       1 Gb/s, 10 Gb/s             256 bytes    0xa0
           SFF-8472       1 Gb/s, 10 Gb/s, 25 GB/s    512 bytes    0xa0, 0xa2
           SFF-8436       40 Gb/s                     256 bytes    0x00
           SFF-8636       100 Gb/s                    256 bytes    0x00

   MMAACC CCaappaabbiilliittyy SSttrruuccttuurree
     When the device driver's mc_getcapab(9E) function entry point is called
     with the capability requested set to MMAACC__CCAAPPAABB__TTRRAANNSSCCEEIIVVEERR, then the
     value of the capability structure is the following structure:

           typedef struct mac_capab_transceiver {
                   uint_t  mct_flags;
                   uint_t  mct_ntransceiveres;
                   int     (*mct_info)(void *driver, uint_t id,
                               mac_transceiver_info_t *infop),
                   int     (*mct_read)(void *driver, uint_t id, uint_t page,
                               void *buf, size_t nbytes, off_t offset,
                               size_t *nwritten)
           } mac_capab_transceiver_t;

     If the device driver supports the MMAACC__CCAAPPAABB__TTRRAANNSSCCEEIIVVEERR capability, it
     should fill in this structure, based on the following rules:

     mmcctt__ffllaaggss
             The _m_c_t___f_l_a_g_s member is used to negotiate extensions with the
             driver. MAC will set the value of _m_c_t___f_l_a_g_s to include all of the
             currently known extensions. The driver should intersect this list
             with the set that they actually support. At this time, no such
             features are defined and the driver should set the member to 00.

     mmcctt__nnttrraannsscceeiivveerrss
             The value of mmcctt__nnttrraannsscceeiivveerrss indicates that the number of
             transceivers present in the device. For most devices, it is
             expected that this value will be set to one. However, some
             devices do support multiple transceivers and PHYs that show up
             behind a single logical MAC.

             It is expected that this value will not change across the
             lifetime of the device being attached. It is important to
             remember that this represents the total possible number of
             transceivers in the device, not how many are currently present
             and powered on.

             The number of transceivers will influence the _i_d argument used in
             the mmcctt__iinnffoo() and mmcctt__rreeaadd() entry points. The transceiver IDs
             will start at zero and go to the value of _m_c_t___n_t_r_a_n_s_c_e_i_v_e_r_s _- _1.
             It is up to the driver to keep the mapping between actual
             transceivers and the transceiver identifiers consistent.

     mmcctt__iinnffoo
             The mmcctt__iinnffoo() entry point is used to set basic information about
             the transceiver. This entry point is _r_e_q_u_i_r_e_d.  If the device
             driver cannot implement this entry point, then it should not
             indicate that it supports the capability.

             The mmcctt__iinnffoo() entry point should fill in information about the
             transceiver with an identifier of _i_d.  See the description above
             of mmcctt__nnttrraannsscceeiivveerrss for more information on how the IDs are
             determined.

             The driver should then proceed to fill in basic information by
             calling the functions described in the section _I_n_f_o_r_m_a_t_i_o_n
             _F_u_n_c_t_i_o_n_s.  After successfully calling all of the functions, the
             driver should return 00.  Othewrise, it should return the
             appropriate error number. For a full list of error numbers, see
             Intro(2).  Common values are:

                  EINVAL             The transceiver identifier _i_d was
                                     invalid.

                  ENOTSUP            This instance of the devices does not
                                     support a transceiver. For example, a
                                     device which sometimes has copper PHYsand
                                     therefore this instance does not have any
                                     PHYs.

                  EIO                An error occurred while trying to read
                                     device registers. For example, an FM-
                                     aware device had an error.

     mmcctt__rreeaadd
             The mmcctt__rreeaadd() function is used to read information from a
             transceiver's i2c bus. The mmcctt__rreeaadd() entry point is an _o_p_t_i_o_n_a_l
             entry point.

             The transceiver should first check the value of _i_d, which
             indicates which transceiver information is being requested.  See
             the description above of mmcctt__nnttrraannsscceeiivveerrss for more information
             on how the IDs are determined.

             The driver should try to read up to _n_b_y_t_e_s of data from the i2c
             bus at page _p_a_g_e.  The driver should start reading at offset
             _o_f_f_s_e_t.  Finally, it should update the value in _n_w_r_i_t_t_e_n with the
             number of bytes written to the buffer _b_u_f.

             If for some reason the driver cannot read all of the requested
             bytes, that is acceptable. Instead it should perform a short
             read. This may occur because the transceiver does not allow reads
             at a requested region or the region is shorter than is common for
             most devices.

             Upon successful completion, the driver should ensure that
             _n_w_r_i_t_t_e_n has been updated and then return 00.  Otherwise, the
             driver should return the appropriate error number. For a full
             list of error numbers, see Intro(2).  Common values are:

                  EINVAL             The value of _i_d represented an invalid
                                     transceiver identifier. The transceiver
                                     i2c page _p_a_g_e is not valid for this type
                                     of device. The value of _o_f_f_s_e_t is beyond
                                     the range supported for this _p_a_g_e.

                  EIO                An error occurred while trying to read
                                     the device i2c pages.

   TTrraannsscceeiivveerr IInnffoorrmmaattiioonn FFuunnccttiioonnss
     The mmcctt__iinnffoo() entry point is the primary required entry point for a
     device driver which supports this capability. The information structure
     is opaque to the device driver. Instead, a series of informational
     functions is available to the device driver to call on the transceiver.
     The device drivers should try to call and fill in as many of these as
     possible.  There are three different properties that a driver can set:

           1.   The kind of the transceiver.

           2.   Whether the transceiver is present.

           3.   Whether the transceiver is usable.

     To set the transceiver kind, the driver should call
     mac_transceiver_info_set_type(9F).  The transceiver's kind comes from the
     following enumeration of values from the enumerator
     mac_transceiver_kind_t:

           MAC_TRANSCEIVER_UNKNOWN
                         The transceiver's kind is unknown.

           MAC_TRANSCEIVER_SYNTHETIC
                         The device firmware does not allow direct access to
                         the transceiver and instead abstracts it.

           MAC_TRANSCEIVER_INF_8074
                         The transceiver is compliant with the IINNFF--88007744 MSA
                         and implements the i2c informational page 0xa0.

           MAC_TRANSCEIVER_SFF_8472
                         The transceiver conforms to the IINNFF--88447722 standard and
                         implements the i2c informational page 0xa0 and 0xa2.

           MAC_TRANSCEIVER_SFF_8436
                         The transceiver conforms to the SSFFFF--88443366 standard and
                         implements the i2c informational page 0x00.

           MAC_TRANSCEIVER_SFF_8636
                         The transceiver conforms to the SSFFFF--88663366 standard and
                         implements the i2c informational page 0x00.

     To set whether or not the transceiver is present, the driver should call
     mac_transceiver_info_set_present(9F).  This is used to indicate whether
     the transceiver is plugged in or not.  If the transceiver is a part of
     the NIC, then this function should always be called with the value set to
     B_TRUE.

     Finally, the driver has the ability to provide information about whether
     or not the transceiver is usable or not. A transceiver may be present,
     but not usable, if the hardware and firmware support a limited number of
     transceivers. To set this information, the driver should call
     mac_transceiver_info_set_usable(9F).  If the transceiver is not present,
     then the driver should not call this function.

   OOppaaqquuee TTrraannsscceeiivveerrss
     Some devices abstract the nature of the transceiver and do not allow
     direct access to the transceiver. In this case, if the device driver
     still has access to enough information to know if the transceiver is at
     least present, then it should still implement the mmcctt__iinnffoo() entry point
     and set the transceiver kind to MAC_TRANSCEIVER_SYNTHETIC.

   LLoocckkiinngg aanndd DDaattaa AAcccceessss
     Calls to get information about the transceivers may come at the same time
     as general I/O requests to the device to send or receive data. The driver
     should make sure that reading data from the i2c bus of the transceiver
     does not interfere with the device's functionality in this regard.
     Different locks should be used.

     On some devices, reading from the transceiver's i2c bus might cause a
     disruption of service to the device. For example, on some devices a phy
     reset may be required or come about as a side effect of trying to read
     the device. If any kind of disruption would be caused, then the driver
     must not implement the _m_c_t___r_e_a_d entry point.

CCOONNTTEEXXTT
     The various callback functions will be called from kkeerrnneell context. These
     functions will never be called from iinntteerrrruupptt context.

SSEEEE AALLSSOO
     Intro(2), mac(9E), mc_getcapab(9E), mac_register(9F),
     mac_transceiver_info_set_present(9F), mac_transceiver_info_set_type(9F),
     mac_transceiver_info_set_usable(9F), mac_register(9S),

     _S_F_P _(_S_m_a_l_l _F_o_r_m_f_a_c_t_o_r _P_l_u_g_g_a_b_l_e_) _I_n_t_e_r_f_a_c_e, INF-8074i, SFF Committee, May
     12, 2001, Revision 1.0.

     _D_i_a_g_n_o_s_t_i_c _M_o_n_i_t_o_r_i_n_g _I_n_t_e_r_f_a_c_e _f_o_r _O_p_t_i_c_a_l _T_r_a_n_s_c_e_i_v_e_r_s, SFF-8472,
     November 21, 2014, Revision 12.2.

     _Q_S_F_P_+ _1_0 _G_b_s _4_X _P_L_U_G_G_A_B_L_E _T_R_A_N_S_C_E_I_V_E_R, SFF-8436, October 31, 2013,
     Revision 4.8.

     _M_a_n_a_g_e_m_e_n_t _I_n_t_e_r_f_a_c_e _f_o_r _C_a_b_l_e_d _E_n_v_i_r_o_n_m_e_n_t_s, SFF-8636, January 26, 2016,
     Revision 2.7.

illumos                        February 17, 2017                       illumos
